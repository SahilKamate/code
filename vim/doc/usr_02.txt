*usr_02.txt*	For Vim version 9.0.  Last change: 2021 Apr 24

		     VIM USER MANUAL - by Bram Moolenaar

			    The first steps in Vim


This chapter provides just enough information to edit a file with Vim.  Not
well or fast, but you can edit.  Take some time to practice with these
commands, they form the base for what follows.

|02.1|	Running Vim for the First Time
|02.2|	Inserting text
|02.3|	Moving around
|02.4|	Deleting characters
|02.5|	Undo and Redo
|02.6|	Other editing commands
|02.7|	Getting out
|02.8|	Finding help

     Next chapter: |usr_03.txt|  Moving around
 Previous chapter: |usr_01.txt|  About the manuals
Table of contents: |usr_toc.txt|

==============================================================================
*02.1*	Running Vim for the First Time

To start Vim, enter this command: >

	gvim file.txt

In UNIX you can type this at any command prompt.  If you are running Microsoft
Windows, open a Command Prompt and enter the command.
   In either case, Vim starts editing a file called file.txt.  Because this
is a new file, you get a blank window. This is what your screen will look
like:

	+---------------------------------------+
	|#					|
	|~					|
	|~					|
	|~					|
	|~					|
	|"file.txt" [New file]			|
	+---------------------------------------+
		('#' is the cursor position.)

The tilde (~) lines indicate lines not in the file.  In other words, when Vim
runs out of file to display, it displays tilde lines.  At the bottom of the
screen, a message line indicates the file is named file.txt and shows that you
are creating a new file.  The message information is temporary and other
information overwrites it.


THE VIM COMMAND

The gvim command causes the editor to create a new window for editing.  If you
use this command: >

	vim file.txt

the editing occurs inside your command window.  In other words, if you are
running inside an xterm, the editor uses your xterm window.  If you are using
an MS-Windows command prompt window, the editing occurs inside this window.
The text in the window will look the same for both versions, but with gvim you
have extra features, like a menu bar.  More about that later.

==============================================================================
*02.2*	Inserting text

The Vim editor is a modal editor.  That means that the editor behaves
differently, depending on which mode you are in.  The two basic modes are
called Normal mode and Insert mode.  In Normal mode the characters you type
are commands.  In Insert mode the characters are inserted as text.
   Since you have just started Vim it will be in Normal mode.  To start Insert
mode you type the "i" command (i for Insert).  Then you can enter
the text.  It will be inserted into the file.  Do not worry if you make
mistakes; you can correct them later.  To enter the following programmer's
limerick, this is what you type: >

	iA very intelligent turtle
	Found programming UNIX a hurdle

After typing "turtle" you press the <Enter> key to start a new line.  Finally
you press the <Esc> key to stop Insert mode and go back to Normal mode.  You
now have two lines of text in your Vim window:

	+---------------------------------------+
	|A very intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+


WHAT IS THE MODE?

To be able to see what mode you are in, type this command: >

	:set showmode

You will notice that when typing the colon Vim moves the cursor to the last
line of the window.  That's where you type colon commands (commands that start
with a colon).  Finish this command by pressing the <Enter> key (all commands
that start with a colon are finished this way).
   Now, if you type the "i" command Vim will display --INSERT-- at the bottom
of the window.  This indicates you are in Insert mode.

	+---------------------------------------+
	|A very intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|-- INSERT --				|
	+---------------------------------------+

If you press <Esc> to go back to Normal mode the last line will be made blank.


GETTING OUT OF TROUBLE

One of the problems for Vim novices is mode confusion, which is caused by
forgetting which mode you are in or by accidentally typing a command that
switches modes.  To get back to Normal mode, no matter what mode you are in,
press the <Esc> key.  Sometimes you have to press it twice.  If Vim beeps back
at you, you already are in Normal mode.

==============================================================================
*02.3*	Moving around

After you return to Normal mode, you can move around by using these keys:

	h   left						*hjkl*
	j   down
	k   up
	l   right

At first, it may appear that these commands were chosen at random.  After all,
who ever heard of using l for right?  But actually, there is a very good
reason for these choices: Moving the cursor is the most common thing you do in
an editor, and these keys are on the home row of your right hand.  In other
words, these commands are placed where you can type them the fastest
(especially when you type with ten fingers).

	Note:
	You can also move the cursor by using the arrow keys.  If you do,
	however, you greatly slow down your editing because to press the arrow
	keys, you must move your hand from the text keys to the arrow keys.
	Considering that you might be doing it hundreds of times an hour, this
	can take a significant amount of time.
	   Also, there are keyboards which do not have arrow keys, or which
	locate them in unusual places; therefore, knowing the use of the hjkl
	keys helps in those situations.

One way to remember these commands is that h is on the left, l is on the
right and j points down.  In a picture: >

		       k
		   h     l
		     j

The best way to learn these commands is by using them.  Use the "i" command to
insert some more lines of text.  Then use the hjkl keys to move around and
insert a word somewhere.  Don't forget to press <Esc> to go back to Normal
mode.  The |vimtutor| is also a nice way to learn by doing.

For Japanese users, Hiroshi Iwatani suggested using this:

			Komsomolsk
			    ^
			    |
	   Huan Ho	<--- --->  Los Angeles
	(Yellow river)	    |
			    v
			  Java (the island, not the programming language)

==============================================================================
*02.4*	Deleting characters

To delete a character, move the cursor over it and type "x".  (This is a
throwback to the old days of the typewriter, when you deleted things by typing
xxxx over them.)  Move the cursor to the beginning of the first line, for
example, and type xxxxxxx (seven x's) to delete "A very ".  The result should
look like this:

	+---------------------------------------+
	|intelligent turtle			|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+

Now you can insert new text, for example by typing: >

	iA young <Esc>

This begins an insert (the i), inserts the words "A young", and then exits
insert mode (the final <Esc>).	The result:

	+---------------------------------------+
	|A young intelligent turtle		|
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|					|
	+---------------------------------------+


DELETING A LINE

To delete a whole line use the "dd" command.  The following line will
then move up to fill the gap:

	+---------------------------------------+
	|Found programming UNIX a hurdle	|
	|~					|
	|~					|
	|~					|
	|					|
	+---------------------------------------+


DELETING A LINE BREAK

In Vim you can join two lines together, which means that the line break
between them is deleted.  The "J" command does this.
   Take these two lines:

	A young intelligent ~
	turtle ~

Move the cursor to the first line and press "J":

	A young intelligent turtle ~

==============================================================================
*02.5*	Undo and Redo

Suppose you delete too much.  Well, you can type it in again, but an easier
way exists.  The "u" command undoes the last edit.  Take a look at this in
action: After using "dd" to delete the first line, "u" brings it back.
   Another one: Move the cursor to the A in the first line:

	A young intelligent turtle ~

Now type xxxxxxx to delete "A young".  The result is as follows:

	 intelligent turtle ~

Type "u" to undo the last delete.  That delete removed the g, so the undo
restores the character.

	g intelligent turtle ~

The next "u" command restores the next-to-last character deleted:

	ng intelligent turtle ~

The next "u" command gives you the u, and so on:

	ung intelligent turtle ~
	oung intelligent turtle ~
	young intelligent turtle ~
	 young intelligent turtle ~
	A young intelligent turtle ~

	Note:
	If you type "u" twice, and the result is that you get the same text
	back, you have Vim configured to work Vi compatible.  Look here to fix
	this: |not-compatible|.
	   This text assumes you work "The Vim Way".  You might prefer to use
	the good old Vi way, but you will have to watch out for small
	differences in the text then.


REDO

If you undo too many times, you can press CTRL-R (redo) to reverse the
preceding command.  In other words, it undoes the undo.  To see this in
action, press CTRL-R twice.  The character A and the space after it disappear:

	young intelligent turtle ~

There's a special version of the undo command, the "U" (undo line) command.
The undo line command undoes all the changes made on the last line that was
edited.  Typing this command twice cancels the preceding "U".

	A very intelligent turtle ~
	  xxxx				Delete very

	A intelligent turtle ~
		      xxxxxx		Delete turtle

	A intelligent ~
					Restore line with "U"
	A very intelligent turtle ~
					Undo "U" with "u"
	A intelligent ~

The "U" command is a change by itself, which the "u" command undoes and CTRL-R
redoes.  This might be a bit confusing.  Don't worry, with "u" and CTRL-R you
can go to any of the situations you had.  More about that in section |32.2|.

==============================================================================
*02.6*	Other editing commands

Vim has a large number of commands to change the text.  See |Q_in| and below.
Here are a few often used ones.


APPENDING

The "i" command inserts a character before the character under the cursor.
That works fine; but what happens if you want to add stuff to the end of the
line?  For that you need to insert text after the cursor.  This is done with
the "a" (append) command.
   For example, to change the line

	and that's not saying much for the turtle. ~
to
	and that's not saying much for the turtle!!! ~

move the cursor over to the dot at the end of the line. Then type "x" to
delete the period.  The cursor is now positioned at the end of the line on the
e in turtle.  Now type >

	a!!!<Esc>

to append three exclamation points after the e in turtle:

	and that's not saying much for the turtle!!! ~


OPENING UP A NEW LINE

The "o" command creates a new, empty line below the cursor and puts Vim in
Insert mode.  Then you can type the text for the new line.
   Suppose the cursor is somewhere in the first of these two lines:

	A very intelligent turtle ~
	Found programming UNIX a hurdle ~

If you now use the "o" command and type new text: >

	oThat liked using Vim<Esc>

The result is:

	A very intelligent turtle ~
	That liked using Vim ~
	Found programming UNIX a hurdle ~

The "O" command (uppercase) opens a line above the cursor.


USING A COUNT

Suppose you want to move up nine lines.  You can type "kkkkkkkkk" or you can
enter the command "9k".  In fact, you can precede many commands with a number.
Earlier in this chapter, for instance, you added three exclamation points to
the end of a line by typing "a!!!<Esc>".  Another way to do this is to use the
command "3a!<Esc>".  The count of 3 tells the command that follows to triple
its effect.  Similarly, to delete three characters, use the command "3x".  The
count always comes before the command it applies to.

==============================================================================
*02.7*	Getting out

To exit, use the "ZZ" command.  This command writes the file and exits.

	Note:
	Unlike many other editors, Vim does not automatically make a backup
	file.  If you type "ZZ", your changes are committed and there's no
	turning back.  You can configure the Vim editor to produce backup
	files; see |07.4|.


DISCARDING CHANGES

Sometimes you will make a sequence of changes and suddenly realize you were
better off before you started.  Not to worry; Vim has a
quit-and-throw-things-away command.  It is: >

	:q!

Don't forget to press <Enter> to finish the command.

For those of you interested in the details, the three parts of this command
are the colon (:), which enters Command-line mode; the q command, which tells
the editor to quit; and the override command modifier (!).
   The override command modifier is needed because Vim is reluctant to throw
away changes.  If you were to just type ":q", Vim would display an error
message and refuse to exit:

	E37: No write since last change (use ! to override) ~

By specifying the override, you are in effect telling Vim, "I know that what
I'm doing looks stupid, but I really want to do this."

If you want to continue editing with Vim: The ":e!" command reloads the
original version of the file.

==============================================================================
*02.8*	Finding help

Everything you always wanted to know can be found in the Vim help files.
Don't be afraid to ask!

If you know what you are looking for, it is usually easier to search for it
using the help system, instead of using Google.  Because the subjects follow
a certain style guide.

Also the help has the advantage of belonging to your particular Vim version.
You won't see help for commands added later.  These would not work for you.

To get generic help use this command: >

	:help

You could also use the first function key <F1>.  If your keyboard has a <Help>
key it might work as well.
   If you don't supply a subject, ":help" displays the general help window.
The creators of Vim did something very clever (or very lazy) with the help
system: They made the help window a normal editing window.  You can use all
the normal Vim commands to move through the help information.  Therefore h, j,
k, and l move left, down, up and right.
   To get out of the help window, use the same command you use to get out of
the editor: "ZZ".  This will only close the help window, not exit Vim.

As you read the help text, you will notice some text enclosed in vertical bars
(for example, |help|).  This indicates a hyperlink.  If you position the
cursor anywhere between the bars and press CTRL-] (jump to tag), the help
system takes you to the indicated subject.  (For reasons not discussed here,
the Vim terminology for a hyperlink is tag.  So CTRL-] jumps to the location
of the tag given by the word under the cursor.)
   After a few jumps, you might want to go back.  CTRL-T (pop tag) takes you
back to the preceding position.  CTRL-O (jump to older position) also works
nicely here.
   At the top of the help screen, there is the notation *help.txt*.  This name
between "*" characters is used by the help system to define a tag (hyperlink
destination).
   See |29.1| for details about using tags.

To get help on a given subject, use the following command: >

	:help {subject}

To get help on the "x" command, for example, enter the following: >

	:help x

To find out how to delete text, use this command: >

	:help deleting

To get a complete index of all Vim commands, use the following command: >

	:help index

When you need to get help for a control character command (for example,
CTRL-A), you need to spell it with the prefix "CTRL-". >

	:help CTRL-A

The Vim editor has many different modes.  By default, the help system displays
the normal-mode commands.  For example, the following command displays help
for the normal-mode CTRL-H command: >

	:help CTRL-H

To identify other modes, use a mode prefix.  If you want the help for the
insert-mode version of a command, use "i_".  For CTRL-H this gives you the
following command: >

	:help i_CTRL-H

When you start the Vim editor, you can use several command-line arguments.
These all begin with a dash (-).  To find what the -t argument does, for
example, use the command: >

	:help -t

The Vim editor has a number of options that enable you to configure and
customize the editor.  If you want help for an option, you need to enclose it
in single quotation marks.  To find out what the 'number' option does, for
example, use the following command: >

	:help 'number'

The table with all mode prefixes can be found below: |help-summary|.

Special keys are enclosed in angle brackets.  To find help on the up-arrow key
in Insert mode, for instance, use this command: >

	:help i_<Up>

If you see an error message that you don't understand, for example:

	E37: No write since last change (use ! to override) ~

You can use the error ID at the start to find help about it: >

	:help E37


Summary: 					*help-summary*  >

1) Use Ctrl-D after typing a topic and let Vim show all available topics.
   Or press Tab to complete: >
	:help some<Tab>
<   More information on how to use the help: >
	:help helphelp

2) Follow the links in bars to related help.  You can go from the detailed
   help to the user documentation, which describes certain commands more from
   a user perspective and less detailed.  E.g. after: >
	:help pattern.txt
<   You can see the user guide topics |03.9| and |usr_27.txt| in the
   introduction.

3) Options are enclosed in single apostrophes.  To go to the help topic for the
   list option: >
	:help 'list'
<   If you only know you are looking for a certain option, you can also do: >
	:help options.txt
<   to open the help page which describes all option handling and then search
   using regular expressions, e.g. textwidth.
   Certain options have their own namespace, e.g.: >
	:help cpo-<letter>
<   for the corresponding flag of the 'cpoptions' settings, substitute <letter>
   by a specific flag, e.g.: >
	:help cpo-;
<   And for the 'guioptions' flags: >
	:help go-<letter>

4) Normal mode commands do not have a prefix. To go to the help page for the
   "gt" command: >
	:help gt

5) Insert mode commands start with i_.  Help for deleting a word: >
	:help i_CTRL-W

6) Visual mode commands start with v_.  Help for jumping to the other side of
   the Visual area: >
	:help v_o

7) Command line editing and arguments start with c_.  Help for using the
   command argument %: >
	:help c_%

8) Ex-commands always start with ":", so to go to the ":s" command help: >
	:help :s

9) Commands specifically for debugging start with ">".  To go to the help
   for the "cont" debug command: >
	:help >cont

10) Key combinations.  They usually start with a single letter indicating
    the mode for which they can be used.  E.g.: >
	:help i_CTRL-X
<    takes you to the family of CTRL-X commands for insert mode which can be
    used to auto-complete different things.  Note, that certain keys will
    always be written the same, e.g. Control will always be CTRL.
    For normal mode commands there is no prefix and the topic is available at
    :h CTRL-<Letter>. E.g.  >
	:help CTRL-W
<    In contrast >
	:help c_CTRL-R
<    will describe what the CTRL-R does when entering commands in the Command
    line and >
	:help v_CTRL-A
<    talks about incrementing numbers in visual mode and >
	:help g_CTRL-A
<    talks about the "g<C-A>" command (e.g. you have to press "g" then
    <CTRL-A>).  Here the "g" stands for the normal command "g" which always
    expects a second key before doing something similar to the commands
    starting with "z".

11) Regexp items always start with /.  So to get help for the "\+" quantifier
    in Vim regexes: >
	:help /\+
<    If you need to know everything about regular expressions, start reading
    at: >
	:help pattern.txt

12) Registers always start with "quote". To find out about the special ":"
    register: >
	:help quote:

13) Vim script is available at >
	:help eval.txt
<    Certain aspects of the language are available at :h expr-X where "X" is a
    single letter. E.g.  >
	:help expr-!
<    will take you to the topic describing the "!" (Not) operator for Vim
    script.
    Also important is >
	:help function-list
<    to find a short description of all functions available.  Help topics for
    Vim script functions always include the "()", so: >
	:help append()
<    talks about the append Vim script function rather than how to append text
    in the current buffer.

14) Mappings are talked about in the help page :h |map.txt|. Use >
	:help mapmode-i
<    to find out about the |:imap| command.  Also use :map-topic
    to find out about certain subtopics particular for mappings.  e.g: >
	:help :map-local
<    for buffer-local mappings or >
	:help map-bar
<    for how the '|' is handled in mappings.

15) Command definitions are talked about :h command-topic, so use >
	:help command-bar
<    to find out about the '!' argument for custom commands.

16) Window management commands always start with CTRL-W, so you find the
    corresponding help at :h CTRL-W_letter.  E.g. >
	:help CTRL-W_p
<    for moving the previous accessed window.  You can also access >
	:help windows.txt
<    and read your way through if you are looking for window handling
    commands.

17) Use |:helpgrep| to search in all help pages (and also of any installed
    plugins).  See |:helpgrep| for how to use it.
    To search for a topic: >
	:helpgrep topic
<    This takes you to the first match.  To go to the next one: >
	:cnext
<    All matches are available in the quickfix window which can be opened
    with: >
	:copen
<    Move around to the match you like and press Enter to jump to that help.

18) The user manual.  This describes help topics for beginners in a rather
    friendly way.  Start at |usr_toc.txt| to find the table of content (as you
    might have guessed): >
	:help usr_toc.txt
<    Skim over the contents to find interesting topics. The "Digraphs" and
    "Entering special characters" items are in chapter 24, so to go to that
    particular help page: >
	:help usr_24.txt
<    Also if you want to access a certain chapter in the help, the chapter
    number can be accessed directly like this: >
	:help 10.1
<    which goes to chapter 10.1 in |usr_10.txt| and talks about recording
    macros.

19) Highlighting groups.  Always start with hl-groupname.  E.g. >
	:help hl-WarningMsg
<    talks about the WarningMsg highlighting group.

20) Syntax highlighting is namespaced to :syn-topic.  E.g. >
	:help :syn-conceal
<    talks about the conceal argument for the ":syn" command.

21) Quickfix commands usually start with :c while location list commands
    usually start with :l

22) Autocommand events can be found by their name: >
	:help BufWinLeave
<    To see all possible events: >
	:help autocommand-events

23) Command-line switches always start with "-".  So for the help of the -f
    command switch of Vim use: >
	:help -f

24) Optional features always start with "+".  To find out about the
    conceal feature use: >
	:help +conceal

25) Documentation for included filetype specific functionality is usually
    available in the form ft-<filetype>-<functionality>.  So >
	:help ft-c-syntax
<    talks about the C syntax file and the option it provides.  Sometimes,
    additional sections for omni completion >
	:help ft-php-omni
<    or filetype plugins >
	:help ft-tex-plugin
<    are available.

26) Error and Warning codes can be looked up directly in the help.  So >
	:help E297
<    takes you exactly to the description of the swap error message and >
	:help W10
<    talks about the warning "Changing a readonly file".
    Sometimes, however, those error codes are not described, but rather are
    listed at the Vim command that usually causes this.  So: >
	:help E128
<    takes you to the |:function| command


==============================================================================

Next chapter: |usr_03.txt|  Moving around
*usr_03.txt*	For Vim version 9.0.  Last change: 2020 Sep 03

		     VIM USER MANUAL - by Bram Moolenaar

			     Moving around


Before you can insert or delete text the cursor has to be moved to the right
place.  Vim has a large number of commands to position the cursor.  This
chapter shows you how to use the most important ones.  You can find a list of
these commands below |Q_lr|.

|03.1|	Word movement
|03.2|	Moving to the start or end of a line
|03.3|	Moving to a character
|03.4|	Matching a parenthesis
|03.5|	Moving to a specific line
|03.6|	Telling where you are
|03.7|	Scrolling around
|03.8|	Simple searches
|03.9|	Simple search patterns
|03.10|	Using marks

     Next chapter: |usr_04.txt|  Making small changes
 Previous chapter: |usr_02.txt|  The first steps in Vim
Table of contents: |usr_toc.txt|

==============================================================================
*03.1*	Word movement

To move the cursor forward one word, use the "w" command.  Like most Vim
commands, you can use a numeric prefix to move past multiple words.  For
example, "3w" moves three words.  This figure shows how it works (starting at
the position marked with "x"):

	This is a line with example text ~
	  x-->-->->----------------->
	   w  w  w    3w

Notice that "w" moves to the start of the next word if it already is at the
start of a word.
   The "b" command moves backward to the start of the previous word:

	This is a line with example text ~
	<----<--<-<---------<--x
	   b   b b    2b      b

There is also the "e" command that moves to the next end of a word and "ge",
which moves to the previous end of a word:

	This is a line with example text ~
	   <----<----x---->------------>
	   2ge   ge     e       2e

If you are at the last word of a line, the "w" command will take you to the
first word in the next line.  Thus you can use this to move through a
paragraph, much faster than using "l".  "b" does the same in the other
direction.

A word ends at a non-word character, such as a ".", "-" or ")".  To change
what Vim considers to be a word, see the 'iskeyword' option.  If you try this
out in the help directly, 'iskeyword' needs to be reset for the examples to
work: >
	:set iskeyword&
It is also possible to move by white-space separated WORDs.  This is not a
word in the normal sense, that's why the uppercase is used.  The commands for
moving by WORDs are also uppercase, as this figure shows:

	       ge      b	  w				e
	       <-     <-	 --->			       --->
	This is-a line, with special/separated/words (and some more). ~
	   <----- <-----	 -------------------->	       ----->
	     gE      B			 W			 E

With this mix of lowercase and uppercase commands, you can quickly move
forward and backward through a paragraph.

==============================================================================
*03.2*	Moving to the start or end of a line

The "$" command moves the cursor to the end of a line.  If your keyboard has
an <End> key it will do the same thing.

The "^" command moves to the first non-blank character of the line.  The "0"
command (zero) moves to the very first character of the line, and the <Home>

key does the same thing.  In a picture ("." indicates a space):

		  ^
	     <-----------x
	.....This is a line with example text ~
	<----------------x   x-------------->
		0		   $

(the "....." indicates blanks here)

   The "$" command takes a count, like most movement commands.  But moving to
the end of the line several times doesn't make sense.  Therefore it causes the
editor to move to the end of another line.  For example, "1$" moves you to
the end of the first line (the one you're on), "2$" to the end of the next
line, and so on.
   The "0" command doesn't take a count argument, because the "0" would be
part of the count.  Unexpectedly, using a count with "^" doesn't have any
effect.

==============================================================================
*03.3*	Moving to a character

One of the most useful movement commands is the single-character search
command.  The command "fx" searches forward in the line for the single
character x.  Hint: "f" stands for "Find".
   For example, you are at the beginning of the following line.  Suppose you
want to go to the h of human.  Just execute the command "fh" and the cursor
will be positioned over the h:

	To err is human.  To really foul up you need a computer. ~
	---------->--------------->
	    fh		 fy

This also shows that the command "fy" moves to the end of the word really.
   You can specify a count; therefore, you can go to the "l" of "foul" with
"3fl":

	To err is human.  To really foul up you need a computer. ~
		  --------------------->
			   3fl

The "F" command searches to the left:

	To err is human.  To really foul up you need a computer. ~
		  <---------------------
			    Fh

The "tx" command works like the "fx" command, except it stops one character
before the searched character.  Hint: "t" stands for "To".  The backward
version of this command is "Tx"

	To err is human.  To really foul up you need a computer. ~
		   <------------  ------------->
			Th		tn

These four commands can be repeated with ";".  "," repeats in the other
direction.  The cursor is never moved to another line.  Not even when the
sentence continues.

Sometimes you will start a search, only to realize that you have typed the
wrong command.  You type "f" to search backward, for example, only to realize
that you really meant "F".  To abort a search, press <Esc>.  So "f<Esc>" is an
aborted forward search and doesn't do anything.  Note: <Esc> cancels most
operations, not just searches.

==============================================================================
*03.4*	Matching a parenthesis

When writing a program you often end up with nested () constructs.  Then the
"%" command is very handy: It moves to the matching paren.  If the cursor is
on a "(" it will move to the matching ")".  If it's on a ")" it will move to
the matching "(".

			    %
			 <----->
		if (a == (b * c) / d) ~
		   <---------------->
			    %

This also works for [] and {} pairs.  (This can be defined with the
'matchpairs' option.)

When the cursor is not on a useful character, "%" will search forward to find
one.  Thus if the cursor is at the start of the line of the previous example,
"%" will search forward and find the first "(".  Then it moves to its match:

		if (a == (b * c) / d) ~
		---+---------------->
			   %

==============================================================================
*03.5*	Moving to a specific line

If you are a C or C++ programmer, you are familiar with error messages such as
the following:

	prog.c:33: j   undeclared (first use in this function) ~

This tells you that you might want to fix something on line 33.  So how do you
find line 33?  One way is to do "9999k" to go to the top of the file and "32j"
to go down thirty-two lines.  It is not a good way, but it works.  A much
better way of doing things is to use the "G" command.  With a count, this
command positions you at the given line number.  For example, "33G" puts you
on line 33.  (For a better way of going through a compiler's error list, see
|usr_30.txt|, for information on the :make command.)
   With no argument, "G" positions you at the end of the file.  A quick way to
go to the start of a file use "gg".  "1G" will do the same, but is a tiny bit
more typing.

	    |	first line of a file   ^
	    |	text text text text    |
	    |	text text text text    |  gg
	7G  |	text text text text    |
	    |	text text text text
	    |	text text text text
	    V	text text text text    |
		text text text text    |  G
		text text text text    |
		last line of a file    V

Another way to move to a line is using the "%" command with a count.  For
example "50%" moves you to halfway the file.  "90%" goes to near the end.

The previous assumes that you want to move to a line in the file, no matter if
it's currently visible or not.  What if you want to move to one of the lines
you can see?  This figure shows the three commands you can use:

			+---------------------------+
		H -->	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		M -->	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		L -->	| text sample text	    |
			+---------------------------+

Hints: "H" stands for Home, "M" for Middle and "L" for Last.  Alternatively,
"H" for high, "M" for Middle and "L" for low.

==============================================================================
*03.6*	Telling where you are

To see where you are in a file, there are three ways:

1.  Use the CTRL-G command.  You get a message like this (assuming the 'ruler'
    option is off):

	"usr_03.txt" line 233 of 650 --35%-- col 45-52 ~

    This shows the name of the file you are editing, the line number where the
    cursor is, the total number of lines, the percentage of the way through
    the file and the column of the cursor.
       Sometimes you will see a split column number.  For example, "col 2-9".
    This indicates that the cursor is positioned on the second character, but
    because character one is a tab, occupying eight spaces worth of columns,
    the screen column is 9.

2.  Set the 'number' option.  This will display a line number in front of
    every line: >

	:set number
<
    To switch this off again: >

	:set nonumber
<
    Since 'number' is a boolean option, prepending "no" to its name has the
    effect of switching it off.  A boolean option has only these two values,
    it is either on or off.
       Vim has many options.  Besides the boolean ones there are options with
    a numerical value and string options.  You will see examples of this where
    they are used.

3.  Set the 'ruler' option.  This will display the cursor position in the
    lower right corner of the Vim window: >

	:set ruler

Using the 'ruler' option has the advantage that it doesn't take much room,
thus there is more space for your text.

==============================================================================
*03.7*	Scrolling around

The CTRL-U command scrolls down half a screen of text.  Think of looking
through a viewing window at the text and moving this window up by half the
height of the window.  Thus the window moves up over the text, which is
backward in the file.  Don't worry if you have a little trouble remembering
which end is up.  Most users have the same problem.
   The CTRL-D command moves the viewing window down half a screen in the file,
thus scrolls the text up half a screen.

				       +----------------+
				       | some text	|
				       | some text	|
				       | some text	|
	+---------------+	       | some text	|
	| some text	|  CTRL-U  --> |		|
	|		|	       | 123456		|
	| 123456	|	       +----------------+
	| 7890		|
	|		|	       +----------------+
	| example	|  CTRL-D -->  | 7890		|
	+---------------+	       |		|
				       | example	|
				       | example	|
				       | example	|
				       | example	|
				       +----------------+

To scroll one line at a time use CTRL-E (scroll up) and CTRL-Y (scroll down).
Think of CTRL-E to give you one line Extra.  (If you use MS-Windows compatible
key mappings CTRL-Y will redo a change instead of scroll.)

To scroll forward by a whole screen (except for two lines) use CTRL-F.  To
scroll backwards, use CTRL-B.  These should be easy to remember: F for
Forwards and B for Backwards.

A common issue is that after moving down many lines with "j" your cursor is at
the bottom of the screen.  You would like to see the context of the line with
the cursor.  That's done with the "zz" command.

	+------------------+		 +------------------+
	| earlier text	   |		 | earlier text	    |
	| earlier text	   |		 | earlier text	    |
	| earlier text	   |		 | earlier text	    |
	| earlier text	   |   zz  -->	 | line with cursor |
	| earlier text	   |		 | later text	    |
	| earlier text	   |		 | later text	    |
	| line with cursor |		 | later text	    |
	+------------------+		 +------------------+

The "zt" command puts the cursor line at the top, "zb" at the bottom.  There
are a few more scrolling commands, see |Q_sc|.  To always keep a few lines of
context around the cursor, use the 'scrolloff' option.

==============================================================================
*03.8*	Simple searches

To search for a string, use the "/string" command.  To find the word include,
for example, use the command: >

	/include

You will notice that when you type the "/" the cursor jumps to the last line
of the Vim window, like with colon commands.  That is where you type the word.
You can press the backspace key (backarrow or <BS>) to make corrections.  Use
the <Left> and <Right> cursor keys when necessary.
   Pressing <Enter> executes the command.

	Note:
	The characters .*[]^%/\?~$ have special meanings.  If you want to use
	them in a search you must put a \ in front of them.  See below.

To find the next occurrence of the same string use the "n" command.  Use this
to find the first #include after the cursor: >

	/#include

And then type "n" several times.  You will move to each #include in the text.
You can also use a count if you know which match you want.  Thus "3n" finds
the third match.  You can also use a count with "/": "4/the" goes to the
fourth match of "the".

The "?" command works like "/" but searches backwards: >

	?word

The "N" command repeats the last search the opposite direction.  Thus using
"N" after a "/" command searches backwards, using "N" after "?" searches
forwards.


IGNORING CASE

Normally you have to type exactly what you want to find.  If you don't care
about upper or lowercase in a word, set the 'ignorecase' option: >

	:set ignorecase

If you now search for "word", it will also match "Word" and "WORD".  To match
case again: >

	:set noignorecase


HISTORY

Suppose you do three searches: >

	/one
	/two
	/three

Now let's start searching by typing a simple "/" without pressing <Enter>.  If
you press <Up> (the cursor key), Vim puts "/three" on the command line.
Pressing <Enter> at this point searches for three.  If you do not press
<Enter>, but press <Up> instead, Vim changes the prompt to "/two".  Another
press of <Up> moves you to "/one".
   You can also use the <Down> cursor key to move through the history of
search commands in the other direction.

If you know what a previously used pattern starts with, and you want to use it
again, type that character before pressing <Up>.  With the previous example,
you can type "/o<Up>" and Vim will put "/one" on the command line.

The commands starting with ":" also have a history.  That allows you to recall
a previous command and execute it again.  These two histories are separate.


SEARCHING FOR A WORD IN THE TEXT

Suppose you see the word "TheLongFunctionName" in the text and you want to
find the next occurrence of it.  You could type "/TheLongFunctionName", but
that's a lot of typing.  And when you make a mistake Vim won't find it.
   There is an easier way: Position the cursor on the word and use the "*"
command.  Vim will grab the word under the cursor and use it as the search
string.
   The "#" command does the same in the other direction.  You can prepend a
count: "3*" searches for the third occurrence of the word under the cursor.


SEARCHING FOR WHOLE WORDS

If you type "/the" it will also match "there".  To only find words that end
in "the" use: >

	/the\>

The "\>" item is a special marker that only matches at the end of a word.
Similarly "\<" only matches at the beginning of a word.  Thus to search for
the word "the" only: >

	/\<the\>

This does not match "there" or "soothe".  Notice that the "*" and "#" commands
use these start-of-word and end-of-word markers to only find whole words (you
can use "g*" and "g#" to match partial words).


HIGHLIGHTING MATCHES

While editing a program you see a variable called "nr".  You want to check
where it's used.  You could move the cursor to "nr" and use the "*" command
and press "n" to go along all the matches.
   There is another way.  Type this command: >

	:set hlsearch

If you now search for "nr", Vim will highlight all matches.  That is a very
good way to see where the variable is used, without the need to type commands.
   To switch this off: >

	:set nohlsearch

Then you need to switch it on again if you want to use it for the next search
command.  If you only want to remove the highlighting, use this command: >

	:nohlsearch

This doesn't reset the option.  Instead, it disables the highlighting.  As
soon as you execute a search command, the highlighting will be used again.
Also for the "n" and "N" commands.


TUNING SEARCHES

There are a few options that change how searching works.  These are the
essential ones:
>
	:set incsearch

This makes Vim display the match for the string while you are still typing it.
Use this to check if the right match will be found.  Then press <Enter> to
really jump to that location.  Or type more to change the search string.
>
	:set nowrapscan

This stops the search at the end of the file.  Or, when you are searching
backwards, it stops the search at the start of the file.  The 'wrapscan'
option is on by default, thus searching wraps around the end of the file.


INTERMEZZO

If you like one of the options mentioned before, and set it each time you use
Vim, you can put the command in your Vim startup file.
   Edit the file, as mentioned at |not-compatible|.  Or use this command to
find out where it is: >

	:scriptnames

Edit the file, for example with: >

	:edit ~/.vimrc

Then add a line with the command to set the option, just like you typed it in
Vim.  Example: >

	Go:set hlsearch<Esc>

"G" moves to the end of the file.  "o" starts a new line, where you type the
":set" command.  You end insert mode with <Esc>.  Then write and close the
file: >

	ZZ

If you now start Vim again, the 'hlsearch' option will already be set.

==============================================================================
*03.9*	Simple search patterns

The Vim editor uses regular expressions to specify what to search for.
Regular expressions are an extremely powerful and compact way to specify a
search pattern.  Unfortunately, this power comes at a price, because regular
expressions are a bit tricky to specify.
   In this section we mention only a few essential ones.  More about search
patterns and commands can be found in chapter 27 |usr_27.txt|.  You can find
the full explanation here: |pattern|.


BEGINNING AND END OF A LINE

The ^ character matches the beginning of a line.  On an English-US keyboard
you find it above the 6.  The pattern "include" matches the word include
anywhere on the line.  But the pattern "^include" matches the word include
only if it is at the beginning of a line.
   The $ character matches the end of a line.  Therefore, "was$" matches the
word was only if it is at the end of a line.

Let's mark the places where "/the" matches in this example line with "x"s:

	the solder holding one of the chips melted and the ~
	xxx			  xxx		       xxx

Using "/the$" we find this match:

	the solder holding one of the chips melted and the ~
						       xxx

And with "/^the" we find this one:
	the solder holding one of the chips melted and the ~
	xxx

You can try searching with "/^the$"; it will only match a single line
consisting entirely of "the".  White space does matter here, thus if a line
contains a space after the word, like "the ", the pattern will not match.


MATCHING ANY SINGLE CHARACTER

The . (dot) character matches any existing character.  For example, the
pattern "c.m" matches a string whose first character is a c, whose second
character is anything, and whose third character is m.  Example:

	We use a computer that became the cummin winter. ~
		 xxx		 xxx	  xxx


MATCHING SPECIAL CHARACTERS

If you really want to match a dot, you must avoid its special meaning by
putting a backslash before it.
   If you search for "ter.", you will find these matches:

	We use a computer that became the cummin winter. ~
		      xxxx			    xxxx

Searching for "ter\." only finds the second match.

==============================================================================
*03.10*	Using marks

When you make a jump to a position with the "G" command, Vim remembers the
position from before this jump.  This position is called a mark.  To go back
where you came from, use this command: >

	``

This ` is a backtick or open single-quote character.
   If you use the same command a second time you will jump back again.  That's
because the "`" command is a jump itself, and the position from before this
jump is remembered.

Generally, every time you do a command that can move the cursor further than
within the same line, this is called a jump.  This includes the search
commands "/" and "n" (it doesn't matter how far away the match is).  But not
the character searches with "fx" and "tx" or the word movements "w" and "e".
   Also, "j" and "k" are not considered to be a jump, even when you use a
count to make them move the cursor quite a long way away.

The "``" command jumps back and forth, between two points.  The CTRL-O command
jumps to older positions (Hint: O for older).  CTRL-I then jumps back to newer
positions (Hint: for many common keyboard layouts, I is just next to O).
Consider this sequence of commands: >

	33G
	/^The
	CTRL-O

You first jump to line 33, then search for a line that starts with "The".
Then with CTRL-O you jump back to line 33.  Another CTRL-O takes you back to
where you started.  If you now use CTRL-I you jump to line 33 again.  And
to the match for "The" with another CTRL-I.


	     |	example text   ^	     |
	33G  |	example text   |  CTRL-O     | CTRL-I
	     |	example text   |	     |
	     V	line 33 text   ^	     V
	     |	example text   |	     |
       /^The |	example text   |  CTRL-O     | CTRL-I
	     V	There you are  |	     V
		example text

	Note:
	CTRL-I is the same as <Tab>.

The ":jumps" command gives a list of positions you jumped to.  The entry which
you used last is marked with a ">".


NAMED MARKS							*bookmark*

Vim enables you to place your own marks in the text.  The command "ma" marks
the place under the cursor as mark a.  You can place 26 marks (a through z) in
your text.  You can't see them, it's just a position that Vim remembers.
   To go to a mark, use the command `{mark}, where {mark} is the mark letter.
Thus to move to the a mark:
>
	`a

The command "'mark" (single quotation mark, or apostrophe) moves you to the
beginning of the line containing the mark.  This differs from the "`mark"
command, which also moves you to the marked column.

The marks can be very useful when working on two related parts in a file.
Suppose you have some text near the start of the file you need to look at,
while working on some text near the end of the file.
   Move to the text at the start and place the s (start) mark there: >

	ms

Then move to the text you want to work on and put the e (end) mark there: >

	me

Now you can move around, and when you want to look at the start of the file,
you use this to jump there: >

	's

Then you can use '' to jump back to where you were, or 'e to jump to the text
you were working on at the end.
   There is nothing special about using s for start and e for end, they are
just easy to remember.

You can use this command to get a list of marks: >

	:marks

You will notice a few special marks.  These include:

	'	The cursor position before doing a jump
	"	The cursor position when last editing the file
	[	Start of the last change
	]	End of the last change

==============================================================================

Next chapter: |usr_04.txt|  Making small changes

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:

Copyright: see |manual-copyright|  vim:tw=83:ts=8:noet:ft=help:norl:
